
// calculate the tree and loop matrix element of the process
// q qbar -> g t tbar for given phase-space point in evaluation example

#include <iostream>
#include <cmath>
#include "openloops.h"

int main() {

  double p[5][4] =
  { {500.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, 
    0, 0, 500.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000}, 
  {500.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, 
    0, 0, -500.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000}, 
{421.8125582935075499299999999999999999999996419441012460497857019735693793950821515491354622706676735788278165273368359, 
  72.3820876039188476599999999999999999999972992702059571696605505568192629035369517774339484517120979489845922216773033, 
  342.3370704279178316540750115746198744322446846759360789907521168183712432645142927778935133284892137944485367818317974, 
  163.0705305658970034367869570158571759678120357579592935924183386996803940499249376730733837594890221884942701762689235}, 
 {463.8660649840359724299999999999999999999971611268736396095675372272139074456290527586255125619407735371169110294431448, 
  -151.6247358499944084499999999999999999999977701046807121153290357562389466645776002826214931551440656676277285441756248, 
  -322.7651756913571148299999999999999999999970860743138539649276030633454000181622658265654431802849089194751286413520575, 
  -243.1137739477561528857253063181619124037570706665473042363065983868394503044961806795037344319030372943373237998748259}, 
 {114.3213767224564776400000000000000000000031969290251143406467607992167131592887956922390251673915528840552724432200193, 
  79.2426482460755607900000000000000000000004708344747549456684851994196837610406485051875447034319677186431363224983215, 
  -19.5718947365607168240750115746198744322475986016222250258245137550258432463520269513280701482043048749734081404797399, 
  80.0432433818591494489383493023047364359450349085880106438882596871590562545712430064303506724140152296039555144736644}};

  double sqrts = sqrt((p[0][0]+p[1][0])*(p[0][0]+p[1][0]) - (p[0][3]+p[1][3])*(p[0][3]+p[1][3]));
  double mt = sqrt((p[3][0])*(p[3][0]) - (p[3][1])*(p[3][1]) - (p[3][2])*(p[3][2]) - (p[3][3])*(p[3][3]));
  
  double mq = 0., mu = 1, alphas = 0.118; // dimensionful: GeV
  double m2_tree, m2_loop[3], acc;

  // pure QCD (order_s fixed by LO/NLO)
  ol_setparameter_int("order_ew", 0);
  ol_setparameter_int("polenorm", 0);

  // first example: massless d quark
  ol_setparameter_double("mass(1)", mq);
  ol_setparameter_double("mass(6)", mt);

  // Increase verbosity level to list loaded libraries
  ol_setparameter_int("verbose", 1);

  // example process d dbar -> g t tbar (since q are massless: should not matter)
  //
  // second argument of ol_register_process:
  // 1 for tree-like matrix elements (tree, color and spin correlations),
  // 11 for loop, 12 for loop^2 (loop induced: processes without tree)

  int id = ol_register_process("2 -2 -> -6 6 21", 11);

  // Initialize OpenLoops
  ol_start();


  if (id > 0) {
    // Set parameter: strong coupling
    ol_setparameter_double("alpha_s", alphas);
    // Set parameter: renormalization scale
    ol_setparameter_double("mu", mu);

    // Obtain a random phase-space point in the format pp[5*N] from Rambo
    double pp[25] = {
    500.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, 
    0, 0, 500.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, 0,

  500.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, 
    0, 0, -500.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, 0,

421.8125582935075499299999999999999999999996419441012460497857019735693793950821515491354622706676735788278165273368359, 
  72.3820876039188476599999999999999999999972992702059571696605505568192629035369517774339484517120979489845922216773033, 
  342.3370704279178316540750115746198744322446846759360789907521168183712432645142927778935133284892137944485367818317974, 
  163.0705305658970034367869570158571759678120357579592935924183386996803940499249376730733837594890221884942701762689235, mt,

 463.8660649840359724299999999999999999999971611268736396095675372272139074456290527586255125619407735371169110294431448, 
  -151.6247358499944084499999999999999999999977701046807121153290357562389466645776002826214931551440656676277285441756248, 
  -322.7651756913571148299999999999999999999970860743138539649276030633454000181622658265654431802849089194751286413520575, 
  -243.1137739477561528857253063181619124037570706665473042363065983868394503044961806795037344319030372943373237998748259, mt,

 114.3213767224564776400000000000000000000031969290251143406467607992167131592887956922390251673915528840552724432200193, 
  79.2426482460755607900000000000000000000004708344747549456684851994196837610406485051875447034319677186431363224983215, 
  -19.5718947365607168240750115746198744322475986016222250258245137550258432463520269513280701482043048749734081404797399, 
  80.0432433818591494489383493023047364359450349085880106438882596871590562545712430064303506724140152296039555144736644, 0};

    std::cout.precision(20);
    std::cout << std::endl;
    std::cout << "Tree and loop matrix element of the process" << std::endl;
    std::cout << "d dbar -> g t tbar" << std::endl;
    std::cout << "for the phase-space point" << std::endl;
    for (int k = 0; k < 5; k++) {
      std::cout << "P[" << k+1 << "] = " << pp[5*k] << "  " << pp[5*k+1]
                << "  " << pp[5*k+2] << "  " << pp[5*k+3]  << "  m="
            << pp[5*k+4]<< std::endl;
    }

    // evaluate tree matrix element
    ol_evaluate_tree(id, pp, &m2_tree);

    // print tree result
    std::cout << std::endl;
    std::cout << "ol_evaluate_tree" << std::endl;
    std::cout << "Tree:       " << m2_tree << std::endl;

    // evaluate loop matrix element (which also returns the tree)
    ol_evaluate_loop(id, pp, &m2_tree, m2_loop, &acc);

    // print loop result
    std::cout << std::endl;
    std::cout << "ol_evaluate_loop (avaraged)" << std::endl;
    std::cout << "Tree:       " << m2_tree << std::endl;
    std::cout << "Loop ep^0 / (alpha_s/[4Pi] Tree):  " << m2_loop[0] / alphas * 4 * M_PI / m2_tree << std::endl;
    std::cout << "Loop ep^-1 / (alpha_s/[4Pi] Tree): " << m2_loop[1] / alphas * 4 * M_PI / m2_tree << std::endl;
    std::cout << "Loop ep^-2 / (alpha_s/[4Pi] Tree): " << m2_loop[2] / alphas * 4 * M_PI / m2_tree << std::endl;
    std::cout << "Accuracy:   " << acc << std::endl;
    std::cout << std::endl;
  }


  ol_finish();

  return 0; // result has GeV^-2 ???
}