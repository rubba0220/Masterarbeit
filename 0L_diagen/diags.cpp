#include "DiaGen.hpp"
#include "IdSolver.hpp"
#include <signal.h>

bool topo_ps = true;
int topo_count = 1;
string topo_name;

int diag_count = 0;
int proto_count = 0;

PrototypeMap prototypes;

/******************************************************************************
 *                                                                            *
 * QCDDiagram                                                                 *
 *                                                                            *
 ******************************************************************************/

class QCDDiagram : public Diagram
{
public:

  QCDDiagram(const Diagram& d) : Diagram(d) {};

private:

  virtual void
  print_vertex(ostream& output, int node, int fermion_chain_index = 0) const;
};

void
QCDDiagram::print_vertex(ostream& output, int n, int fermion_chain_index) const
{
  Vertex::pointer v = _vertex[n];
  const int degree = v->_original_fields.size();

  // determine the indices and momenta of the original vertex fields.
  // All the momenta are in-going and the indices are compatible with those
  // generated by print_line().

  vector<int> edge(degree);
  vector<string> index(degree);
  vector<vector<int> > momentum(degree);

  vector<bool> assigned(degree, false);

  for (int d = 0; d < 2; ++d)
    for (vector<int>::const_iterator e = _node_desc[n]._edges[d].begin();
	 e != _node_desc[n]._edges[d].end(); ++e)
      {
	for (int i = 0; i < degree; ++i)
	  {
	    if (!assigned[i] && _line[*e]._field[1-d] == v->_original_fields[i])
	      {
		assigned[i] = true;

		edge[i] = *e;

		ostringstream current_index;
		current_index << "v" << n << "l" << *e;

		if (_edge_desc[*e]._node[0] == _edge_desc[*e]._node[1])
		  if (d) current_index << "out";
		  else current_index << "in";

		index[i] = current_index.str();

		for (int j = 0; j < _momentum_basis.size(); ++j)
		  momentum[i].push_back((1-2*d)*_edge_desc[*e]._momentum[j]);

		break;
	      }
	  }
      }

  // make the map from the field type to the respective field position on
  // the original vertex field list.

  vector<vector<int> > position(Field::n_types);
  
  for (int i = 0; i < degree; ++i)
    position[v->_original_fields[i]->_type].push_back(i);

  // output according to the type

  switch (v->_type)
    {
    case Vertex::FermionVector:
      {
	output << "\t*G(" << fermion_chain_index << ", "
	       << index[position[Field::Vector][0]] << ")*(";
	print_vertex_value(output, v->_value[0], n, edge);
	output << ")\n";
      }
      break;
    case Vertex::GhostVector:
      {
	output << "\t*(";
	print_momentum(output,momentum[position[Field::Ghost][0]],
		       _momentum_basis,index[position[Field::Vector][0]]);
	output << ")*(";
	print_vertex_value(output, v->_value[0], n, edge);
	output << ")\n";
      }
      break;
    case Vertex::TripleVector:
      {
	output << "\t*VVV(";
	print_momentum(output, momentum[0], _momentum_basis);
	output << ", " << index[0] << ", ";
	print_momentum(output, momentum[1], _momentum_basis);
	output << ", " << index[1] << ", ";
	print_momentum(output, momentum[2], _momentum_basis);
	output << ", " << index[2] << ")\n\t*(";
	print_vertex_value(output, v->_value[0], n, edge);
	output << ")\n";
      }
      break;
    case Vertex::QuadrupleVector:
      {
	output << "\t*(+d_(" << index[0] << ", " << index[1] << ")*d_("
	       << index[2] << ", " << index[3] << ")\n\t  *(";
	print_vertex_value(output, v->_value[0], n, edge);
	output << ")\n\t  +d_(" << index[0] << ", " << index[2] << ")*d_(" 
	       << index[1] << ", " << index[3] << ")\n\t  *(";
	print_vertex_value(output, v->_value[1], n, edge);
	output << ")\n\t  +d_(" << index[0] << ", " << index[3] << ")*d_("
	       << index[1] << ", " << index[2] << ")\n\t  *(";
	print_vertex_value(output, v->_value[2], n, edge);
	output << "))\n";
      }	
      break;
    }
}

/******************************************************************************
 *                                                                            *
 * print_diagram                                                              *
 *                                                                            *
 ******************************************************************************/

void
print_diagram(ostream& diags, const Diagram& d)
{
  ////////////////////////////////////////////////////////////
  // the tree level is treated separately

  if (d.n_cycles() == 0)
    {
      diags << "*--#[ d" << ++diag_count << " :\n\n";

      d.print_info(diags);
      
      diags << "\n#define nf \"0\"\n";
      diags << "\n#define nl \"0\"\n";
      
      diags << "\ng d" << diag_count << " =\n\n";
      
      QCDDiagram qcddiag(d);
      qcddiag.assign_momenta();
      qcddiag.print(diags);
      
      diags << "\n;\n\n";
      
      diags << "*--#] d" << diag_count << " :\n\n";

      return;
    }

  ////////////////////////////////////////////////////////////
  // count fermion chains
	  
  vector<vector<int> > closed_fermion_chains = d.closed_fermion_chains();

  const int nf = closed_fermion_chains.size();
  int nl = 0;
  for (vector<vector<int> >::iterator c = closed_fermion_chains.begin();
       c != closed_fermion_chains.end(); ++c)
    if (d.line(c->front()).first->_name == "q") ++nl;

  ////////////////////////////////////////////////////////////
  // create the associated scalar diagram
	  
  ScalarDiagram sd(d.n_nodes());

  for (int e = 0; e < d.n_edges(); ++e)
    {
      pair<int, int> adjacent_nodes = d.adjacent_nodes(e);

      string mass;
      if (!d.is_external_edge(e) || !d.is_external_node(adjacent_nodes.first))
	mass = d.line(e).first->_mass;
      else
	mass = d.line(e).second->_mass;

      sd.insert_edge(adjacent_nodes.first, adjacent_nodes.second, mass);
    }

  sd.assign_momenta();

  for (int e = 0; e < d.n_edges(); ++e)
    if (d.is_external_edge(e))
      sd.copy_external_momentum(e,e,d);

  ////////////////////////////////////////////////////////////
  // find the associated prototype

  vector<int> all_edges;
  for (int e = 0; e < d.n_edges(); ++e)
    all_edges.push_back(e);
		  
  vector<pair<Prototype, vector<int> > > subprototypes = 
    sd.subdiagram_prototypes(all_edges);

  if (subprototypes.size() != 1)
    {
      cerr << "Something's wrong with the prototypes for\n\n";
      d.print_info(cerr);
      cerr << endl;
      
      for (vector<pair<Prototype, vector<int> > >::iterator
	     p = subprototypes.begin(); p != subprototypes.end();++p)
        {
	  p->first.print_edge_list(cerr);
	  cerr << endl;
	}

      exit(1);
    }

  Prototype p = subprototypes.front().first;
  vector<int> remap = subprototypes.front().second;
  if (p.has_scaleless_components()) return;

  p.assign_momenta();

  for (int e = 0; e < p.n_edges(); ++e)
    if (p.is_external_edge(e))
      p.copy_external_momentum(e,remap[e],sd);

  p.normalize_momenta();
  
  ////////////////////////////////////////////////////////////
  // insert into the map
  
  bool inserted = prototypes.insert(p);
  if (inserted) ++proto_count;

  ////////////////////////////////////////////////////////////
  // find the prototype inside the map and determine the
  // momentum remapping

  prototypes.init_iterator();

  vector<string> rules;
  NamedPrototype np = prototypes.current_prototype();

  do
    {
      np = prototypes.current_prototype();

      if (np.compare(p) == 0)
	{
	  vector<pair<int, int> > l1 = p.integral_edge_labelling();
	  vector<pair<int, int> > l2 = np.integral_edge_labelling();

	  const vector<string> basis = sd.momentum_basis();

	  for (int i = 0; i < basis.size(); ++i)
	    {
	      for (int e = 0; e < p.n_edges(); ++e)
		{
		  const vector<int> momentum = sd.momentum(remap[l1[e].first]);
		  
		  int pos, count = 0;
		  for (int j = 0; j < basis.size(); ++j)
		    if (momentum[j])
		      {
			++count;
			pos = j;
		      }
		  
		  if (count != 1 || pos != i) continue;
		  
		  const int sign = momentum[pos]*l1[e].second*l2[e].second;
		  
		  ostringstream prototype_momentum;
		  np.print_momentum(l2[e].first, prototype_momentum);
		  
		  string rule(basis[pos]);
		  rule += ",";
		  if (sign < 0) rule += "-(";
		  rule += prototype_momentum.str();
		  if (sign < 0) rule += ")";
		  
		  rules.push_back(rule);
		}
	    }

	  break;
	}
    }
  while (prototypes.next_prototype());

  ////////////////////////////////////////////////////////////
  // print everyting out

  ++diag_count;

  if (inserted)
    cout << proto_count << "\td" << diag_count << "\t"<< np.name << endl;

  diags << "*--#[ d" << diag_count << " :\n\n";

  if (topo_ps)
    {
      d.postscript_print(topo_name);
      ++topo_count;
      topo_ps = false;
    }

  diags << "*\ttopology: " << topo_name << "\n*\n";
  d.print_info(diags);

  diags << "\n#define PROTO \"" << np.name << "\"\n";

  diags << "\n#define nr \"" << rules.size() << "\"\n\n";
  for (int r = 0; r < rules.size(); ++r)
    diags << "#define r" << r+1 << " \"" << rules[r] << "\"\n";

  diags << "\n#define nf \"" << nf << "\"\n";
  diags << "\n#define nl \"" << nl << "\"\n";

  diags << "\ng d" << diag_count << " =\n\n";

  QCDDiagram qcddiag(d);
  qcddiag.assign_momenta();
  qcddiag.print(diags);

  diags << "\n;\n\n";

  diags << "*--#] d" << diag_count << " :\n\n";
}

/******************************************************************************
 *                                                                            *
 * main                                                                       *
 *                                                                            *
 ******************************************************************************/

int
main(int argc, char* argv[])
{
  if (argc != 2)
    {
      cout << "usage: " << argv[0] << " nloops\n";
      exit(0);
    }
      
  const int n_loops = atoi(argv[1]);

  // overriding the default vertex structure (consistent with QCDDiagram)

  int types[] =
    {
      0, 0, 0, 3, Vertex::TripleVector, 1,
      0, 0, 0, 4, Vertex::QuadrupleVector, 3,
      0, 2, 0, 1, Vertex::GhostVector, 1,
      0, 0, 2, 1, Vertex::FermionVector, 1,
    };
  
  Vertex::n_types = 4;
  Vertex::type_by_fields = types;

  Model QCD("fields", "vertices");

  ostringstream name;
  name << "diags" << n_loops << "l.out";
  ofstream diags(name.str().c_str());

  vector<string> in_fields, out_fields;
  vector<string> in_momenta, out_momenta;

  in_fields.push_back("q");
  in_fields.push_back("qbar");
  out_fields.push_back("Q");
  out_fields.push_back("QBar");
  out_fields.push_back("A");

  in_momenta.push_back("p1");
  in_momenta.push_back("p2");
  out_momenta.push_back("p3");
  out_momenta.push_back("p4");
  out_momenta.push_back("p5");

  prototypes.enable(PrototypeMap::Postscript);

  TopologyGenerator topologies(5,n_loops);
  //topologies.enable(TopologyGenerator::OneParticleIrreducible);
  topologies.enable(TopologyGenerator::OnShell);
  topologies.enable(TopologyGenerator::NoTadpoles);

  while (topologies.next_topology())
    {
      ostringstream topo_name_strm;
      topo_name_strm << "t" << topo_count << ".ps";
      topo_name = topo_name_strm.str();
      topo_ps = true;

      DiagramGenerator diagrams(topologies.current_topology(), QCD,
				in_fields, in_momenta,
				out_fields, out_momenta);

      while (diagrams.next_diagram())
	{
	  Diagram d = diagrams.current_diagram();

	  print_diagram(diags, d);
	}
    }

  diags.close();

  if (n_loops) prototypes.complete();
}
